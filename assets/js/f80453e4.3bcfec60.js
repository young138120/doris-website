"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["778869"],{231844:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>o,default:()=>u,assets:()=>l,toc:()=>c,frontMatter:()=>s});var a=JSON.parse('{"id":"sql-manual/sql-reference/Data-Types/QUANTILE_STATE","title":"QUANTILE_STATE","description":"\x3c!--","source":"@site/versioned_docs/version-1.2/sql-manual/sql-reference/Data-Types/QUANTILE_STATE.md","sourceDirName":"sql-manual/sql-reference/Data-Types","slug":"/sql-manual/sql-reference/Data-Types/QUANTILE_STATE","permalink":"/docs/1.2/sql-manual/sql-reference/Data-Types/QUANTILE_STATE","draft":false,"unlisted":false,"tags":[],"version":"1.2","frontMatter":{"title":"QUANTILE_STATE","language":"en"},"sidebar":"docs","previous":{"title":"BITMAP","permalink":"/docs/1.2/sql-manual/sql-reference/Data-Types/BITMAP"},"next":{"title":"ARRAY","permalink":"/docs/1.2/sql-manual/sql-reference/Data-Types/ARRAY"}}'),i=t("785893"),r=t("250065");let s={title:"QUANTILE_STATE",language:"en"},o=void 0,l={},c=[{value:"QUANTILE_STATE",id:"quantile_state",level:2},{value:"description",id:"description",level:3},{value:"notice",id:"notice",level:3},{value:"example",id:"example",level:3},{value:"keywords",id:"keywords",level:3}];function d(e){let n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"quantile_state",children:"QUANTILE_STATE"}),"\n",(0,i.jsx)(n.h3,{id:"description",children:"description"}),"\n",(0,i.jsx)(n.p,{children:"QUANTILE_STATE"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"QUANTILE_STATE cannot be used as a key column, and the aggregation type is QUANTILE_UNION when building the table.\nThe user does not need to specify the length and default value. The length is controlled within the system according to the degree of data aggregation.\nAnd the QUANTILE_STATE column can only be queried or used through the supporting QUANTILE_PERCENT, QUANTILE_UNION and TO_QUANTILE_STATE functions.    \nQUANTILE_STATE is a type for calculating the approximate value of quantiles. Different values with the same key are pre-aggregated during loading process. When the number of aggregated values does not exceed 2048, all data are recorded in detail. When the number of aggregated values is greater than 2048, [TDigest] is used. (https://github.com/tdunning/t-digest/blob/main/docs/t-digest-paper/histo.pdf) algorithm to aggregate (cluster) the data and save the centroid points after clustering.\n"})}),"\n",(0,i.jsx)(n.p,{children:"related functions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"QUANTILE_UNION(QUANTILE_STATE):\n  \n  This function is an aggregation function, which is used to aggregate the intermediate results of different quantile calculations. The result returned by this function is still QUANTILE_STATE\n\n\nTO_QUANTILE_STATE(INT/FLOAT/DOUBLE raw_data [,FLOAT compression]):\n   \n   This function converts a numeric type to a QUANTILE_STATE type\n   The compression parameter is optional and can be set in the range [2048, 10000]. \n   The larger the value, the higher the precision of quantile approximation calculations, the greater the memory consumption, and the longer the calculation time.\n   An unspecified or set value for the compression parameter is outside the range [2048, 10000], run with the default value of 2048\n\nQUANTILE_PERCENT(QUANTILE_STATE):\n   This function converts the intermediate result variable (QUANTILE_STATE) of the quantile calculation into a specific quantile value\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"notice",children:"notice"}),"\n",(0,i.jsx)(n.p,{children:"Now QUANTILE_STATE can only used in Aggregate Model Tables. We should turn on the switch for the QUANTILE_STATE types feature with the following command before use:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ mysql-client > admin set frontend config("enable_quantile_state_type"="true");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this way the config will be reset after the FE process restarts. For permanent setting, you can add config\xa0",(0,i.jsx)(n.code,{children:"enable_quantile_state_type=true"}),"\xa0inside fe.conf."]}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select QUANTILE_PERCENT(QUANTILE_UNION(v1)) from test_table group by k1, k2, k3;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"keywords",children:"keywords"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"QUANTILE_STATE, QUANTILE_UNION, TO_QUANTILE_STATE, QUANTILE_PERCENT\n"})})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return s}});var a=t(667294);let i={},r=a.createContext(i);function s(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);