"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["898118"],{73008:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>c,default:()=>u,assets:()=>i,toc:()=>r,frontMatter:()=>o});var a=JSON.parse('{"id":"data-operate/update-delete/sequence-column-manual","title":"Sequence Column","description":"\x3c!--","source":"@site/versioned_docs/version-1.2/data-operate/update-delete/sequence-column-manual.md","sourceDirName":"data-operate/update-delete","slug":"/data-operate/update-delete/sequence-column-manual","permalink":"/docs/1.2/data-operate/update-delete/sequence-column-manual","draft":false,"unlisted":false,"tags":[],"version":"1.2","frontMatter":{"title":"Sequence Column","language":"en"},"sidebar":"docs","previous":{"title":"Delete","permalink":"/docs/1.2/data-operate/update-delete/delete-manual"},"next":{"title":"Schema Change","permalink":"/docs/1.2/advanced/alter-table/schema-change"}}'),l=t("785893"),s=t("250065");let o={title:"Sequence Column",language:"en"},c="Sequence Column",i={},r=[{value:"Applicable scene",id:"applicable-scene",level:2},{value:"Fundamental",id:"fundamental",level:2},{value:"Create Table",id:"create-table",level:3},{value:"Import",id:"import",level:3},{value:"Read",id:"read",level:3},{value:"Cumulative Compaction",id:"cumulative-compaction",level:3},{value:"Base Compaction",id:"base-compaction",level:3},{value:"Syntax",id:"syntax",level:3},{value:"Set <code>sequence_col</code>(recommend)",id:"set-sequence_colrecommend",level:4},{value:"Set <code>sequence_type</code>",id:"set-sequence_type",level:3},{value:"Stream Load",id:"stream-load",level:4},{value:"Broker Load",id:"broker-load",level:4},{value:"Routine Load",id:"routine-load",level:4},{value:"Enable sequence column support",id:"enable-sequence-column-support",level:2},{value:"Usage example",id:"usage-example",level:2}];function d(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"sequence-column",children:"Sequence Column"})}),"\n",(0,l.jsxs)(n.p,{children:["The sequence column currently only supports the Uniq model. The Uniq model is mainly aimed at scenarios that require a unique primary key, which can guarantee the uniqueness constraint of the primary key. However, due to the REPLACE aggregation method, the replacement order of data imported in the same batch is not guaranteed. See ",(0,l.jsx)(n.a,{href:"/docs/1.2/data-table/data-model",children:"Data Model"}),". If the replacement order cannot be guaranteed, the specific data finally imported into the table cannot be determined, and there is uncertainty."]}),"\n",(0,l.jsx)(n.p,{children:"In order to solve this problem, Doris supports the sequence column. The user specifies the sequence column when importing. Under the same key column, the REPLACE aggregation type column will be replaced according to the value of the sequence column. The larger value can replace the smaller value, and vice versa. Cannot be replaced. This method leaves the determination of the order to the user, who controls the replacement order."}),"\n",(0,l.jsx)(n.h2,{id:"applicable-scene",children:"Applicable scene"}),"\n",(0,l.jsx)(n.p,{children:"Sequence columns can only be used under the Uniq data model."}),"\n",(0,l.jsx)(n.h2,{id:"fundamental",children:"Fundamental"}),"\n",(0,l.jsxs)(n.p,{children:["By adding a hidden column ",(0,l.jsx)(n.code,{children:"__DORIS_SEQUENCE_COL__"}),", the type of the column is specified by the user when creating the table, the specific value of the column is determined during import, and the REPLACE column is replaced according to this value."]}),"\n",(0,l.jsx)(n.h3,{id:"create-table",children:"Create Table"}),"\n",(0,l.jsxs)(n.p,{children:["When creating a Uniq table, a hidden column ",(0,l.jsx)(n.code,{children:"__DORIS_SEQUENCE_COL__"})," will be automatically added according to the user-specified type."]}),"\n",(0,l.jsx)(n.h3,{id:"import",children:"Import"}),"\n",(0,l.jsxs)(n.p,{children:["When importing, fe sets the value of the hidden column to the value of the ",(0,l.jsx)(n.code,{children:"order by"})," expression (broker load and routine load), or the value of the ",(0,l.jsx)(n.code,{children:"function_column.sequence_col"})," expression (stream load) during the parsing process, the value column will be Replace with this value. The value of the hidden column ",(0,l.jsx)(n.code,{children:"__DORIS_SEQUENCE_COL__"})," can be set to either a column in the data source or a column in the table structure."]}),"\n",(0,l.jsx)(n.h3,{id:"read",children:"Read"}),"\n",(0,l.jsxs)(n.p,{children:["When the request contains the value column, the ",(0,l.jsx)(n.code,{children:"__DORIS_SEQUENCE_COL__"})," column needs to be additionally read. This column is used as the basis for the replacement order of the REPLACE aggregate function under the same key column. The larger value can replace the smaller value, otherwise it cannot be replaced."]}),"\n",(0,l.jsx)(n.h3,{id:"cumulative-compaction",children:"Cumulative Compaction"}),"\n",(0,l.jsx)(n.p,{children:"The principle is the same as that of the reading process during Cumulative Compaction."}),"\n",(0,l.jsx)(n.h3,{id:"base-compaction",children:"Base Compaction"}),"\n",(0,l.jsx)(n.p,{children:"The principle is the same as the reading process during Base Compaction."}),"\n",(0,l.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,l.jsxs)(n.p,{children:["There are two ways to create a table with sequence column. One is to set the ",(0,l.jsx)(n.code,{children:"sequence_col"})," attribute when creating a table, and the other is to set the ",(0,l.jsx)(n.code,{children:"sequence_type"})," attribute when creating a table."]}),"\n",(0,l.jsxs)(n.h4,{id:"set-sequence_colrecommend",children:["Set ",(0,l.jsx)(n.code,{children:"sequence_col"}),"(recommend)"]}),"\n",(0,l.jsx)(n.p,{children:"When you create the Uniq table, you can specify the mapping of sequence column to other columns"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"PROPERTIES (\n    \"function_column.sequence_col\" = 'column_name',\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:"The sequence_col is used to specify the mapping of the sequence column to a column in the table, which can be integral and time (DATE, DATETIME). The type of this column cannot be changed after creation."}),"\n",(0,l.jsx)(n.p,{children:"The import method is the same as that without the sequence column. It is relatively simple and recommended."}),"\n",(0,l.jsxs)(n.h3,{id:"set-sequence_type",children:["Set ",(0,l.jsx)(n.code,{children:"sequence_type"})]}),"\n",(0,l.jsx)(n.p,{children:"When you create the Uniq table, you can specify the sequence column type"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"PROPERTIES (\n    \"function_column.sequence_type\" = 'Date',\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:"The sequence_type is used to specify the type of the sequence column, which can be integral and time (DATE / DATETIME)."}),"\n",(0,l.jsx)(n.p,{children:"The mapping column needs to be specified when importing."}),"\n",(0,l.jsx)(n.h4,{id:"stream-load",children:"Stream Load"}),"\n",(0,l.jsxs)(n.p,{children:["The syntax of the stream load is to add the mapping of hidden columns corresponding to source_sequence in the ",(0,l.jsx)(n.code,{children:"function_column.sequence_col"})," field in the header, for example"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-shell",children:'curl --location-trusted -u root -H "columns: k1,k2,source_sequence,v1,v2" -H "function_column.sequence_col: source_sequence" -T testData http://host:port/api/testDb/testTbl/_stream_load\n'})}),"\n",(0,l.jsx)(n.h4,{id:"broker-load",children:"Broker Load"}),"\n",(0,l.jsxs)(n.p,{children:["Set the source_sequence field for the hidden column map at ",(0,l.jsx)(n.code,{children:"ORDER BY"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL db1.label1\n(\n    DATA INFILE("hdfs://host:port/user/data/*/test.txt")\n    INTO TABLE `tbl1`\n    COLUMNS TERMINATED BY ","\n    (k1,k2,source_sequence,v1,v2)\n    ORDER BY source_sequence\n)\nWITH BROKER \'broker\'\n(\n    "username"="user",\n    "password"="pass"\n)\nPROPERTIES\n(\n    "timeout" = "3600"\n);\n\n'})}),"\n",(0,l.jsx)(n.h4,{id:"routine-load",children:"Routine Load"}),"\n",(0,l.jsx)(n.p,{children:"The mapping method is the same as above, as shown below"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'   CREATE ROUTINE LOAD example_db.test1 ON example_tbl \n    [WITH MERGE|APPEND|DELETE]\n    COLUMNS(k1, k2, source_sequence, v1, v2),\n    WHERE k1 > 100 and k2 like "%doris%"\n    [ORDER BY source_sequence]\n    PROPERTIES\n    (\n        "desired_concurrent_number"="3",\n        "max_batch_interval" = "20",\n        "max_batch_rows" = "300000",\n        "max_batch_size" = "209715200",\n        "strict_mode" = "false"\n    )\n    FROM KAFKA\n    (\n        "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n        "kafka_topic" = "my_topic",\n        "kafka_partitions" = "0,1,2,3",\n        "kafka_offsets" = "101,0,0,200"\n    );\n'})}),"\n",(0,l.jsx)(n.h2,{id:"enable-sequence-column-support",children:"Enable sequence column support"}),"\n",(0,l.jsxs)(n.p,{children:["If ",(0,l.jsx)(n.code,{children:"function_column.sequence_col"}),"  or  ",(0,l.jsx)(n.code,{children:"function_column.sequence_type"})," is set when creating a new table, the new table will support sequence column. For a table that does not support sequence column, if you want to use this function, you can use the following statement: ",(0,l.jsx)(n.code,{children:'ALTER TABLE example_db.my_table ENABLE FEATURE "SEQUENCE_LOAD" WITH PROPERTIES ("function_column.sequence_type" = "Date")'})," to enable."]}),"\n",(0,l.jsxs)(n.p,{children:["If you are not sure whether a table supports sequence column, you can display hidden columns by setting a session variable ",(0,l.jsx)(n.code,{children:"SET show_hidden_columns=true"}),", then use ",(0,l.jsx)(n.code,{children:"desc tablename"}),", if there is a ",(0,l.jsx)(n.code,{children:"__DORIS_SEQUENCE_COL__"})," column in the output, it is supported, if not, it is not supported ."]}),"\n",(0,l.jsx)(n.h2,{id:"usage-example",children:"Usage example"}),"\n",(0,l.jsx)(n.p,{children:"Let's take the stream Load as an example to show how to use it"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Create a table that supports sequence column."}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Create the test_table data table of the unique model and specify that the sequence column maps to the ",(0,l.jsx)(n.code,{children:"modify_date"})," column in the table."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE test.test_table\n(\n    user_id bigint,\n    date date,\n    group_id bigint,\n    modify_date date,\n    keyword VARCHAR(128)\n)\nUNIQUE KEY(user_id, date, group_id)\nDISTRIBUTED BY HASH (user_id) BUCKETS 32\nPROPERTIES(\n    "function_column.sequence_col" = \'modify_date\',\n    "replication_num" = "1",\n    "in_memory" = "false"\n);\n'})}),"\n",(0,l.jsx)(n.p,{children:"The table structure is shown below"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"MySQL > desc test_table;\n+-------------+--------------+------+-------+---------+---------+\n| Field       | Type         | Null | Key   | Default | Extra   |\n+-------------+--------------+------+-------+---------+---------+\n| user_id     | BIGINT       | No   | true  | NULL    |         |\n| date        | DATE         | No   | true  | NULL    |         |\n| group_id    | BIGINT       | No   | true  | NULL    |         |\n| modify_date | DATE         | No   | false | NULL    | REPLACE |\n| keyword     | VARCHAR(128) | No   | false | NULL    | REPLACE |\n+-------------+--------------+------+-------+---------+---------+\n"})}),"\n",(0,l.jsxs)(n.ol,{start:"2",children:["\n",(0,l.jsx)(n.li,{children:"Import data normally:"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Import the following data"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"1       2020-02-22      1       2020-02-21      a\n1       2020-02-22      1       2020-02-22      b\n1       2020-02-22      1       2020-03-05      c\n1       2020-02-22      1       2020-02-26      d\n1       2020-02-22      1       2020-02-23      e\n1       2020-02-22      1       2020-02-24      b\n"})}),"\n",(0,l.jsx)(n.p,{children:"Take the Stream Load as an example here and map the sequence column to the modify_date column"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-shell",children:"curl --location-trusted -u root: -T testData http://host:port/api/test/test_table/_stream_load\n"})}),"\n",(0,l.jsx)(n.p,{children:"The results is"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"MySQL > select * from test_table;\n+---------+------------+----------+-------------+---------+\n| user_id | date       | group_id | modify_date | keyword |\n+---------+------------+----------+-------------+---------+\n|       1 | 2020-02-22 |        1 | 2020-03-05  | c       |\n+---------+------------+----------+-------------+---------+\n"})}),"\n",(0,l.jsx)(n.p,{children:"In this import, the c is eventually retained in the keyword column because the value of the sequence column (the value in modify_date) is the maximum value: '2020-03-05'."}),"\n",(0,l.jsxs)(n.ol,{start:"3",children:["\n",(0,l.jsx)(n.li,{children:"Guarantee of substitution order"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"After the above steps are completed, import the following data"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"1       2020-02-22      1       2020-02-22      a\n1       2020-02-22      1       2020-02-23      b\n"})}),"\n",(0,l.jsx)(n.p,{children:"Query data"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"MySQL [test]> select * from test_table;\n+---------+------------+----------+-------------+---------+\n| user_id | date       | group_id | modify_date | keyword |\n+---------+------------+----------+-------------+---------+\n|       1 | 2020-02-22 |        1 | 2020-03-05  | c       |\n+---------+------------+----------+-------------+---------+\n"})}),"\n",(0,l.jsx)(n.p,{children:"In this import, the c is eventually retained in the keyword column because the value of the sequence column (the value in modify_date) in all imports is the maximum value: '2020-03-05'.\nTry importing the following data again"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"1       2020-02-22      1       2020-02-22      a\n1       2020-02-22      1       2020-03-23      w\n"})}),"\n",(0,l.jsx)(n.p,{children:"Query data"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"MySQL [test]> select * from test_table;\n+---------+------------+----------+-------------+---------+\n| user_id | date       | group_id | modify_date | keyword |\n+---------+------------+----------+-------------+---------+\n|       1 | 2020-02-22 |        1 | 2020-03-23  | w       |\n+---------+------------+----------+-------------+---------+\n"})}),"\n",(0,l.jsx)(n.p,{children:"At this point, you can replace the original data in the table. To sum up, the sequence column will be compared among all the batches, the largest value of the same key will be imported into Doris table."})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return c},a:function(){return o}});var a=t(667294);let l={},s=a.createContext(l);function o(e){let n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);