"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["171489"],{354837:function(e,n,r){r.r(n),r.d(n,{metadata:()=>i,contentTitle:()=>a,default:()=>u,assets:()=>l,toc:()=>c,frontMatter:()=>o});var i=JSON.parse('{"id":"admin-manual/resource-admin/workload-fusing","title":"Workload Fusing","description":"\x3c!--","source":"@site/versioned_docs/version-3.0/admin-manual/resource-admin/workload-fusing.md","sourceDirName":"admin-manual/resource-admin","slug":"/admin-manual/resource-admin/workload-fusing","permalink":"/docs/3.0/admin-manual/resource-admin/workload-fusing","draft":false,"unlisted":false,"tags":[],"version":"3.0","frontMatter":{"title":"Workload Fusing","language":"en"},"sidebar":"docs","previous":{"title":"Resource Group","permalink":"/docs/3.0/admin-manual/resource-admin/multi-tenant"},"next":{"title":"Use Workload Group limit memory","permalink":"/docs/3.0/admin-manual/resource-admin/use-workload-mem-limit"}}'),s=r("785893"),t=r("250065");let o={title:"Workload Fusing",language:"en"},a=void 0,l={},c=[{value:"Workload Fusing Test",id:"workload-fusing-test",level:2},{value:"Test Env",id:"test-env",level:3},{value:"Workload Fusing By Memory",id:"workload-fusing-by-memory",level:3},{value:"Workload Fusing By Scan Rows",id:"workload-fusing-by-scan-rows",level:3},{value:"Workload Fusing By Query Time",id:"workload-fusing-by-query-time",level:3},{value:"NOTE",id:"note",level:3}];function d(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Workload Fusing is typically applied in scenarios where certain queries excessively consume resources, leading to a decline in the overall availability of the online cluster. In such cases, the cluster can be restored to normal operation by detecting and blocking the abnormal big queries during runtime."}),"\n",(0,s.jsx)(n.p,{children:"If users have already grouped their workload based on query latency, such as assigning big queries to one Workload Group and small queries to another, the big query circuit breaking method can also be used to improve the availability of the small query group."}),"\n",(0,s.jsx)(n.p,{children:"Currently, the big query circuit breaking strategy is mainly implemented through the Workload Policy feature, allowing users to configure specific policies to achieve automatic circuit breaking of big queries."}),"\n",(0,s.jsx)(n.h2,{id:"workload-fusing-test",children:"Workload Fusing Test"}),"\n",(0,s.jsx)(n.h3,{id:"test-env",children:"Test Env"}),"\n",(0,s.jsx)(n.p,{children:"1FE,1BE(96 cores), test data is clickbench."}),"\n",(0,s.jsx)(n.h3,{id:"workload-fusing-by-memory",children:"Workload Fusing By Memory"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Test sql is q29, the query 's peak memory is\uFF08peakMemoryBytes\uFF098G in fe.audit.log."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|User=root|Ctl=internal|Db=hits|State=EOF|ErrorCode=0|ErrorMessage=|Time(ms)=4614|ScanBytes=13107527680|ScanRows=81032736|ReturnRows=11|StmtId=526|QueryId=e5b6c62d624146e4-b7291221492a7cc2|IsQuery=true|isNereids=true|feIp=10.16.10.8|StmtType=SELECT|Stmt=SELECT REGEXP_REPLACE(Referer, '^https?://(?:www\\.)?([^/]+)/.*$', '\\1') AS k, AVG(length(Referer)) AS l, COUNT(*) AS c, MIN(Referer) FROM hits WHERE Referer <> '' GROUP BY k HAVING COUNT(*) > 100000 ORDER BY l DESC LIMIT 25|CpuTimeMS=105631|ShuffleSendBytes=0|ShuffleSendRows=0|SqlHash=b03d48a7e6849912003ad1cff9519957|peakMemoryBytes=8741352477|SqlDigest=|cloudClusterName=UNKNOWN|TraceId=|WorkloadGroup=normal|FuzzyVariables=|scanBytesFromLocalStorage=0|scanBytesFromRemoteStorage=0\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Create a policy which kill the query which using memory exceeds 1G."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"create workload policy cancel_1g_query conditions(query_be_memory_bytes > 1073741824) actions(cancel_query);\n\nmysql [information_schema]>select * from workload_policy;\n+-------+-----------------+------------------------------------+--------------+----------+---------+---------+----------------+\n| ID    | NAME            | CONDITION                          | ACTION       | PRIORITY | ENABLED | VERSION | WORKLOAD_GROUP |\n+-------+-----------------+------------------------------------+--------------+----------+---------+---------+----------------+\n| 11313 | cancel_1g_query | query_be_memory_bytes > 1073741824 | cancel_query |        0 |       1 |       0 |                |\n+-------+-----------------+------------------------------------+--------------+----------+---------+---------+----------------+\n1 row in set (0.02 sec)\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Test again, we can see query is killed by policy cancel_1g_query."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    mysql [information_schema]>SELECT REGEXP_REPLACE(Referer, '^https?://(?:www\\.)?([^/]+)/.*$', '\\1') AS k, AVG(length(Referer)) AS l, COUNT(*) AS c, MIN(Referer) FROM hits.hits WHERE Referer <> '' GROUP BY k HAVING COUNT(*) > 100000 ORDER BY l DESC LIMIT 25;\nERROR 1105 (HY000): errCode = 2, detailMessage = (127.0.0.1)[INTERNAL_ERROR]query ceb0553d359e454f-8939599b2e602d07 cancelled by workload policy: cancel_1g_query, id:11313\n"})}),"\n",(0,s.jsx)(n.h3,{id:"workload-fusing-by-scan-rows",children:"Workload Fusing By Scan Rows"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create the policy."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// disable other policy first.\nalter workload policy cancel_1g_query properties('enabled'='false');\n\ncreate workload policy canel_scan_5kw_query conditions(be_scan_rows > 50000000) actions(cancel_query);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Test query, the query failed because of cancel_1g_query."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"mysql [hits]>SELECT REGEXP_REPLACE(Referer, '^https?://(?:www\\.)?([^/]+)/.*$', '\\1') AS k, AVG(length(Referer)) AS l, COUNT(*) AS c, MIN(Referer) FROM hits.hits WHERE Referer <> '' GROUP BY k HAVING COUNT(*) > 100000 ORDER BY l DESC LIMIT 25;\n\nERROR 1105 (HY000): errCode = 2, detailMessage = (127.0.0.1)[INTERNAL_ERROR]query f9d15001bfc94322-9b63a8b84aef9dee cancelled by workload policy: canel_scan_5kw_query, id:11314\n"})}),"\n",(0,s.jsx)(n.p,{children:"It is important to note that be_scan_rows mainly tracks the amount of data scanned by a query on a single BE. In a production environment, the data for a table is usually distributed across multiple BEs, and the number of rows scanned by a query as seen in the audit is the sum from all BEs."}),"\n",(0,s.jsx)(n.p,{children:"Therefore, when a query fails due to the SCAN data volume, the number of scanned rows in the audit is typically much larger than the value configured in the Policy."}),"\n",(0,s.jsx)(n.h3,{id:"workload-fusing-by-query-time",children:"Workload Fusing By Query Time"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create the policy."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// disable other policy first.\nalter workload policy canel_scan_5kw_query properties('enabled'='false');\n\ncreate workload policy cancel_time_1s_query conditions(query_time > 1000) actions(cancel_query);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Test query, it may be failed because of cancel_time_1s_query."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"mysql [hits]>SELECT REGEXP_REPLACE(Referer, '^https?://(?:www\\.)?([^/]+)/.*$', '\\1') AS k, AVG(length(Referer)) AS l, COUNT(*) AS c, MIN(Referer) FROM hits.hits WHERE Referer <> '' GROUP BY k HAVING COUNT(*) > 100000 ORDER BY l DESC LIMIT 25;\nERROR 1105 (HY000): errCode = 2, detailMessage = (127.0.0.1)[INTERNAL_ERROR]query c6aebdf403e24c62-965daf0bdff179f7 cancelled by workload policy: cancel_time_1s_query, id:11315\n"})}),"\n",(0,s.jsx)(n.h3,{id:"note",children:"NOTE"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Currently, the time interval for the Frontend (FE) to synchronize Workload Policy metadata to the Backend (BE) is 30 seconds, meaning that it may take up to 30 seconds for any policy changes to take effect."}),"\n",(0,s.jsx)(n.li,{children:"Currently, the Backend (BE) executes the strategies configured in the Policy through a scheduled thread with a time interval of 500ms. This means that if a query is very short and completes within 500ms, it may not be subject to the Workload Policy constraints."}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return a},a:function(){return o}});var i=r(667294);let s={},t=i.createContext(s);function o(e){let n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);