"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["707749"],{246007:function(e,n,t){t.r(n),t.d(n,{metadata:()=>o,contentTitle:()=>r,default:()=>m,assets:()=>s,toc:()=>l,frontMatter:()=>c});var o=JSON.parse('{"id":"advanced/best-practice/compaction","title":"Compaction","description":"\x3c!--","source":"@site/versioned_docs/version-1.2/advanced/best-practice/compaction.md","sourceDirName":"advanced/best-practice","slug":"/advanced/best-practice/compaction","permalink":"/docs/1.2/advanced/best-practice/compaction","draft":false,"unlisted":false,"tags":[],"version":"1.2","frontMatter":{"title":"Compaction","language":"en"},"sidebar":"docs","previous":{"title":"Debug Log","permalink":"/docs/1.2/advanced/best-practice/debug-log"},"next":{"title":"Resource management","permalink":"/docs/1.2/advanced/resource"}}'),i=t("785893"),a=t("250065");let c={title:"Compaction",language:"en"},r="Compaction",s={},l=[{value:"Vertical compaction",id:"vertical-compaction",level:2},{value:"Segment compaction",id:"segment-compaction",level:2}];function d(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",version:"version",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"compaction",children:"Compaction"})}),"\n",(0,i.jsx)(n.p,{children:"Doris writes data through a structure similar to LSM-Tree, and continuously merges small files into large ordered files through compaction in the background. Compaction handles operations such as deletion and updating."}),"\n",(0,i.jsx)(n.p,{children:"Appropriately adjusting the compaction strategy can greatly improve load and query efficiency. Doris provides the following two compaction strategies for tuning:"}),"\n",(0,i.jsx)(n.h2,{id:"vertical-compaction",children:"Vertical compaction"}),"\n",(0,i.jsx)(n.version,{since:"1.2.2",children:"\n"}),"\n",(0,i.jsx)(n.p,{children:"Vertical compaction is a new compaction algorithm implemented in Doris 1.2.2, which is used to optimize compaction execution efficiency and resource overhead in large-scale and wide table scenarios. It can effectively reduce the memory overhead of compaction and improve the execution speed of compaction. The test results show that the memory consumption by vertical compaction is only 1/10 of the original compaction algorithm, and the compaction rate is increased by 15%."}),"\n",(0,i.jsx)(n.p,{children:"In vertical compaction, merging by row is changed to merging by column group. The granularity of each merge is changed to column group, which reduces the amount of data involved in single compaction and reduces the memory usage during compaction."}),"\n",(0,i.jsx)(n.p,{children:"BE configuration\uFF1A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enable_vertical_compaction = true"})," will turn on vertical compaction"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"vertical_compaction_num_columns_per_group = 5"})," The number of columns contained in each column group, by testing, the efficiency and memory usage of a group of 5 columns by default is more friendly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"vertical_compaction_max_segment_size"})," is used to configure the size of the disk file after vertical compaction, the default value is 268435456 (bytes)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"segment-compaction",children:"Segment compaction"}),"\n",(0,i.jsx)(n.p,{children:"Segment compaction mainly deals with the large-scale data load. Segment compaction operates during the load process and compact segments inside the job, which is different from normal compaction and vertical compaction. This mechanism can effectively reduce the number of generated segments and avoid the -238 (OLAP_ERR_TOO_MANY_SEGMENTS) errors."}),"\n",(0,i.jsx)(n.p,{children:"The following features are provided by segment compaction:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"reduce the number of segments generated by load"}),"\n",(0,i.jsx)(n.li,{children:"the compacting process is parallel to the load process, which will not increase the load time"}),"\n",(0,i.jsx)(n.li,{children:"memory consumption and computing resources will increase during loading, but the increase is relatively low because it is evenly distributed throughout the long load process."}),"\n",(0,i.jsx)(n.li,{children:"data after segment compaction will have resource and performance advantages in subsequent queries and normal compaction."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"BE configuration:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enable_segcompaction=true"})," turn it on."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"segcompaction_threshold_segment_num"})," is used to configure the interval for merging. The default value 10 means that every 10 segment files will trigger a segment compaction. It is recommended to set between 10 - 30. The larger value will increase the memory usage of segment compaction."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Situations where segment compaction is recommended:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Loading large amounts of data fails at OLAP_ ERR_ TOO_ MANY_ SEGMENTS (errcode - 238) error. Then it is recommended to turn on segment compaction to reduce the quantity of segments during the load process."}),"\n",(0,i.jsx)(n.li,{children:"Too many small files are generated during the load process: although the amount of loading data is reasonable, the generation of a large number of small segment files may also fail the load job because of low cardinality or memory constraints that trigger memtable to be flushed in advance. Then it is recommended to turn on this function."}),"\n",(0,i.jsx)(n.li,{children:"Query immediately after loading. When the load is just finished and the standard compaction has not finished, large number of segment files will affect the efficiency of subsequent queries. If the user needs to query immediately after loading, it is recommended to turn on this function."}),"\n",(0,i.jsx)(n.li,{children:"The pressure of normal compaction is high after loading: segment compaction evenly puts part of the pressure of normal compaction on the loading process. At this time, it is recommended to enable this function."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Situations where segment compaction is not recommended:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When the load operation itself has exhausted memory resources, it is not recommended to use the segment compaction to avoid further increasing memory pressure and causing the load job to fail."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Refer to this ",(0,i.jsx)(n.a,{href:"https://github.com/apache/doris/pull/12866",children:"link"})," for more information about implementation and test results."]})]})}function m(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return c}});var o=t(667294);let i={},a=o.createContext(i);function c(e){let n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);