"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["220415"],{305847:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,contentTitle:()=>a,default:()=>h,assets:()=>l,toc:()=>c,frontMatter:()=>s});var t=JSON.parse('{"id":"data-table/index/prefix-index","title":"Index Overview","description":"\x3c!--","source":"@site/versioned_docs/version-1.2/data-table/index/prefix-index.md","sourceDirName":"data-table/index","slug":"/data-table/index/prefix-index","permalink":"/docs/1.2/data-table/index/prefix-index","draft":false,"unlisted":false,"tags":[],"version":"1.2","frontMatter":{"title":"Index Overview","language":"en"},"sidebar":"docs","previous":{"title":"Best Practices","permalink":"/docs/1.2/data-table/best-practice"},"next":{"title":"BloomFilter index","permalink":"/docs/1.2/data-table/index/bloomfilter"}}'),r=i("785893"),d=i("250065");let s={title:"Index Overview",language:"en"},a="Index Overview",l={},c=[{value:"Prefix Index",id:"prefix-index",level:2},{value:"Example",id:"example",level:2},{value:"Adjust prefix index by ROLLUP",id:"adjust-prefix-index-by-rollup",level:2}];function o(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,d.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"index-overview",children:"Index Overview"})}),"\n",(0,r.jsx)(n.p,{children:"Indexes are used to help quickly filter or find data."}),"\n",(0,r.jsx)(n.p,{children:"Doris currently supports two main types of indexes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"built-in smart indexes, including prefix indexes and ZoneMap indexes."}),"\n",(0,r.jsxs)(n.li,{children:["User-created secondary indexes, including the ",(0,r.jsx)(n.a,{href:"/docs/1.2/data-table/index/bloomfilter",children:"bloomfilter index"})," and ",(0,r.jsx)(n.a,{href:"/docs/1.2/data-table/index/bitmap-index",children:"bitmap index"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The ZoneMap index is the index information automatically maintained for each column in the column storage format, including Min/Max, the number of Null values, and so on. This index is transparent to the user."}),"\n",(0,r.jsx)(n.h2,{id:"prefix-index",children:"Prefix Index"}),"\n",(0,r.jsx)(n.p,{children:"Unlike traditional database designs, Doris does not support creating indexes on arbitrary columns. an OLAP database with an MPP architecture like Doris is typically designed to handle large amounts of data by increasing concurrency."}),"\n",(0,r.jsx)(n.p,{children:"Essentially, Doris data is stored in a data structure similar to an SSTable (Sorted String Table). This structure is an ordered data structure that can be stored sorted by specified columns. On this data structure, it will be very efficient to perform lookups with sorted columns as a condition."}),"\n",(0,r.jsx)(n.p,{children:"In the Aggregate, Unique and Duplicate data models. The underlying data storage is sorted and stored according to the columns specified in the respective table building statements, AGGREGATE KEY, UNIQUE KEY and DUPLICATE KEY."}),"\n",(0,r.jsx)(n.p,{children:"The prefix index, which is based on sorting, is an indexing method to query data quickly based on a given prefix column."}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.p,{children:"We use the first 36 bytes of a row of data as the prefix index of this row of data. Prefix indexes are simply truncated when a VARCHAR type is encountered. We give an example:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The prefix index of the following table structure is user_id(8 Bytes) + age(4 Bytes) + message(prefix 20 Bytes)."}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"ColumnName"}),(0,r.jsx)(n.th,{children:"Type"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"user_id"}),(0,r.jsx)(n.td,{children:"BIGINT"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"age"}),(0,r.jsx)(n.td,{children:"INT"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"message"}),(0,r.jsx)(n.td,{children:"VARCHAR(100)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"max_dwell_time"}),(0,r.jsx)(n.td,{children:"DATETIME"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"min_dwell_time"}),(0,r.jsx)(n.td,{children:"DATETIME"})]})]})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The prefix index of the following table structure is user_name(20 Bytes). Even if it does not reach 36 bytes, because VARCHAR is encountered, it is directly truncated and will not continue further."}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"ColumnName"}),(0,r.jsx)(n.th,{children:"Type"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"user_name"}),(0,r.jsx)(n.td,{children:"VARCHAR(20)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"age"}),(0,r.jsx)(n.td,{children:"INT"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"message"}),(0,r.jsx)(n.td,{children:"VARCHAR(100)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"max_dwell_time"}),(0,r.jsx)(n.td,{children:"DATETIME"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"min_dwell_time"}),(0,r.jsx)(n.td,{children:"DATETIME"})]})]})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When our query condition is the prefix of the prefix index, the query speed can be greatly accelerated. For example, in the first example, we execute the following query:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM table WHERE user_id=1829239 and age=20\uFF1B\n"})}),"\n",(0,r.jsx)(n.p,{children:"This query will be much more efficient than the following query:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM table WHERE age=20\uFF1B\n"})}),"\n",(0,r.jsx)(n.p,{children:"Therefore, when building a table, choosing the correct column order can greatly improve query efficiency."}),"\n",(0,r.jsx)(n.h2,{id:"adjust-prefix-index-by-rollup",children:"Adjust prefix index by ROLLUP"}),"\n",(0,r.jsxs)(n.p,{children:["Because the column order has been specified when the table is created, there is only one prefix index for a table. This may not be efficient for queries that use other columns that cannot hit the prefix index as conditions. Therefore, we can artificially adjust the column order by creating a ROLLUP. For details, please refer to ",(0,r.jsx)(n.a,{href:"/docs/1.2/data-table/hit-the-rollup",children:"ROLLUP"}),"."]})]})}function h(e={}){let{wrapper:n}={...(0,d.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return a},a:function(){return s}});var t=i(667294);let r={},d=t.createContext(r);function s(e){let n=t.useContext(d);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);