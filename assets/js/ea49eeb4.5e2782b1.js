"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["830019"],{995194:function(e,i,n){n.r(i),n.d(i,{metadata:()=>t,contentTitle:()=>l,default:()=>u,assets:()=>c,toc:()=>o,frontMatter:()=>r});var t=JSON.parse('{"id":"query-acceleration/tuning/tuning-plan/transparent-rewriting-with-sync-mv","title":"Transparent Rewriting with Sync-Materialized View","description":"\x3c!--","source":"@site/versioned_docs/version-3.0/query-acceleration/tuning/tuning-plan/transparent-rewriting-with-sync-mv.md","sourceDirName":"query-acceleration/tuning/tuning-plan","slug":"/query-acceleration/tuning/tuning-plan/transparent-rewriting-with-sync-mv","permalink":"/docs/3.0/query-acceleration/tuning/tuning-plan/transparent-rewriting-with-sync-mv","draft":false,"unlisted":false,"tags":[],"version":"3.0","frontMatter":{"title":"Transparent Rewriting with Sync-Materialized View","language":"en"},"sidebar":"docs","previous":{"title":"Optimizing Table Scanning","permalink":"/docs/3.0/query-acceleration/tuning/tuning-plan/optimizing-table-scanning"},"next":{"title":"Transparent Rewriting by Async-Materialized View","permalink":"/docs/3.0/query-acceleration/tuning/tuning-plan/transparent-rewriting-with-async-mv"}}'),a=n("785893"),s=n("250065");let r={title:"Transparent Rewriting with Sync-Materialized View",language:"en"},l=void 0,c={},o=[{value:"Principle",id:"principle",level:2},{value:"Tuning Usage Case",id:"tuning-usage-case",level:2},{value:"Create a Materialized View",id:"create-a-materialized-view",level:3},{value:"Query Data",id:"query-data",level:3},{value:"Summary",id:"summary",level:2}];function d(e){let i={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.h2,{id:"principle",children:"Principle"}),"\n",(0,a.jsx)(i.p,{children:"A sync-materialized view is a special type of table that precomputes and stores data based on a predefined SELECT statement. Its primary purpose is to satisfy users' analytical needs for arbitrary dimensions of raw detailed data while also enabling rapid fixed-dimension analytical queries."}),"\n",(0,a.jsx)(i.p,{children:"Materialized views are suitable for the following scenarios:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Analytical requirements cover both detailed data queries and fixed-dimension queries."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Queries only involve a small subset of columns or rows in the table."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Queries contain time-consuming processing operations, such as long aggregation operations."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Queries require matching different prefix indexes."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"For queries that frequently reuse the same subquery results, a sync-materialized view can significantly enhance performance. Doris automatically maintains the data in the materialized view, ensuring data consistency between the base table and the materialized view without additional manual maintenance costs. During queries, the system automatically matches the optimal materialized view and reads data directly from it."}),"\n",(0,a.jsx)(i.h2,{id:"tuning-usage-case",children:"Tuning Usage Case"}),"\n",(0,a.jsx)(i.p,{children:"The following is a specific example to illustrate the use of single-table materialized views:"}),"\n",(0,a.jsxs)(i.p,{children:["Suppose we have a detailed sales record table ",(0,a.jsx)(i.code,{children:"sales_records"})," that records various information for each transaction, including transaction ID, salesperson ID, store ID, sales date, and transaction amount. Now, we frequently need to perform analytical queries on sales volumes for different stores."]}),"\n",(0,a.jsxs)(i.p,{children:["To optimize the performance of these queries, we can create a materialized view ",(0,a.jsx)(i.code,{children:"store_amt"})," that groups by store ID and sums the sales amounts for the same store. The specific steps are as follows:"]}),"\n",(0,a.jsx)(i.h3,{id:"create-a-materialized-view",children:"Create a Materialized View"}),"\n",(0,a.jsxs)(i.p,{children:["First, we use the following SQL statement to create the materialized view ",(0,a.jsx)(i.code,{children:"store_amt"}),":"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW store_amt AS \nSELECT store_id, SUM(sale_amt) \nFROM sales_records\nGROUP BY store_id;\n"})}),"\n",(0,a.jsx)(i.p,{children:"After submitting the creation task, Doris will asynchronously build this materialized view in the background. We can view the creation progress of the materialized view through the following command:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-sql",children:"SHOW ALTER TABLE MATERIALIZED VIEW FROM db_name; \n"})}),"\n",(0,a.jsxs)(i.p,{children:["When the ",(0,a.jsx)(i.code,{children:"State"})," field changes to ",(0,a.jsx)(i.code,{children:"FINISHED"}),", it indicates that the ",(0,a.jsx)(i.code,{children:"store_amt"})," materialized view has been successfully created."]}),"\n",(0,a.jsx)(i.h3,{id:"query-data",children:"Query Data"}),"\n",(0,a.jsxs)(i.p,{children:["After the materialized view is created, when we query the sales volumes of different stores, Doris will automatically match the ",(0,a.jsx)(i.code,{children:"store_amt"})," materialized view and read the pre-aggregated data directly from it, significantly improving query efficiency."]}),"\n",(0,a.jsx)(i.p,{children:"The query statement is as follows:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-sql",children:"SELECT store_id, SUM(sale_amt) FROM sales_records GROUP BY store_id;\n"})}),"\n",(0,a.jsxs)(i.p,{children:["We can also use the ",(0,a.jsx)(i.code,{children:"EXPLAIN"})," command to check whether the query successfully hits the materialized view:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-sql",children:"EXPLAIN SELECT store_id, SUM(sale_amt) FROM sales_records GROUP BY store_id;\n"})}),"\n",(0,a.jsxs)(i.p,{children:["At the end of the execution plan, if similar content is displayed, it indicates that the query successfully hits the ",(0,a.jsx)(i.code,{children:"store_amt"})," materialized view:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-sql",children:"TABLE: default_cluster:test.sales_records(store_amt), PREAGGREGATION: ON\n"})}),"\n",(0,a.jsx)(i.p,{children:"By following these steps, we can utilize single-table materialized views to optimize query performance and improve the efficiency of data analysis."}),"\n",(0,a.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(i.p,{children:"By creating materialized views, we can significantly enhance the query speed for related aggregation analyses. Materialized views not only enable us to perform statistical analyses quickly but also flexibly support the query requirements of detailed data, making them a very powerful feature in Doris."})]})}function u(e={}){let{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},250065:function(e,i,n){n.d(i,{Z:function(){return l},a:function(){return r}});var t=n(667294);let a={},s=t.createContext(a);function r(e){let i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);