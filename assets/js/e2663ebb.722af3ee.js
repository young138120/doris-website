"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["868515"],{188102:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,contentTitle:()=>o,default:()=>h,assets:()=>l,toc:()=>d,frontMatter:()=>r});var t=JSON.parse('{"id":"data-table/best-practice","title":"Best Practices","description":"\x3c!--","source":"@site/versioned_docs/version-1.2/data-table/best-practice.md","sourceDirName":"data-table","slug":"/data-table/best-practice","permalink":"/docs/1.2/data-table/best-practice","draft":false,"unlisted":false,"tags":[],"version":"1.2","frontMatter":{"title":"Best Practices","language":"en"},"sidebar":"docs","previous":{"title":"Rollup and query","permalink":"/docs/1.2/data-table/hit-the-rollup"},"next":{"title":"Index Overview","permalink":"/docs/1.2/data-table/index/prefix-index"}}'),s=i("785893"),a=i("250065");let r={title:"Best Practices",language:"en"},o="Best Practices",l={},d=[{value:"1 tabulation",id:"1-tabulation",level:2},{value:"1.1 Data Model Selection",id:"11-data-model-selection",level:3},{value:"1.2 Wide Table vs. Star Schema",id:"12-wide-table-vs-star-schema",level:3},{value:"1.3 Partitioning and Bucketing",id:"13-partitioning-and-bucketing",level:3},{value:"1.4 Sparse Index and Bloom Filter",id:"14-sparse-index-and-bloom-filter",level:3},{value:"1.5 Rollup",id:"15-rollup",level:3},{value:"Schema Change",id:"schema-change",level:2}];function c(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,s.jsx)(n.h2,{id:"1-tabulation",children:"1 tabulation"}),"\n",(0,s.jsx)(n.h3,{id:"11-data-model-selection",children:"1.1 Data Model Selection"}),"\n",(0,s.jsx)(n.p,{children:"Doris data model is currently divided into three categories: AGGREGATE KEY, UNIQUE KEY, DUPLICATE KEY. Data in all three models are sorted by KEY."}),"\n",(0,s.jsx)(n.p,{children:"1.1.1. AGGREGATE KEY"}),"\n",(0,s.jsx)(n.p,{children:"When AGGREGATE KEY is the same, old and new records are aggregated. The aggregation functions currently supported are SUM, MIN, MAX, REPLACE."}),"\n",(0,s.jsx)(n.p,{children:"AGGREGATE KEY model can aggregate data in advance and is suitable for reporting and multi-dimensional analysis business."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CREATE TABLE site_visit\n(\nsiteid      INT,\nCity: SMALLINT,\nusername VARCHAR (32),\npv BIGINT   SUM DEFAULT '0'\n)\nAGGREGATE KEY(siteid, city, username)\nDISTRIBUTED BY HASH(siteid) BUCKETS 10;\n"})}),"\n",(0,s.jsx)(n.p,{children:"1.1.2. UNIQUE KEY"}),"\n",(0,s.jsx)(n.p,{children:"When UNIQUE KEY is the same, the new record covers the old record. Before version 1.2, UNIQUE KEY implements the same REPLACE aggregation method as AGGREGATE KEY, and they are essentially the same. We introduced a new merge-on-write implementation for UNIQUE KEY since version 1.2, which have better performance on many scenarios. Suitable for analytical business with updated requirements."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CREATE TABLE sales_order\n(\norderid     BIGINT,\nstatus      TINYINT,\nusername VARCHAR (32),\namount      BIGINT DEFAULT '0'\n)\nKEY (orderid) UNIT\nDISTRIBUTED BY HASH(orderid) BUCKETS 10;\n"})}),"\n",(0,s.jsx)(n.p,{children:"1.1.3. DUPLICATE KEY"}),"\n",(0,s.jsx)(n.p,{children:"Only sort columns are specified, and the same rows are not merged. It is suitable for the analysis business where data need not be aggregated in advance."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CREATE TABLE session_data\n(\nvisitorid SMALLINT,\nsessionid   BIGINT,\nvisit time DATETIME,\nCity CHAR (20),\nprovince    CHAR(20),\nip. varchar (32),\nbrower      CHAR(20),\nurl: VARCHAR (1024)\n)\nDUPLICATE KEY (visitor time, session time)\nDISTRIBUTED BY HASH(sessionid, visitorid) BUCKETS 10;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"12-wide-table-vs-star-schema",children:"1.2 Wide Table vs. Star Schema"}),"\n",(0,s.jsx)(n.p,{children:"When the business side builds tables, in order to adapt to the front-end business, they often do not distinguish between dimension information and indicator information, and define the Schema as a large wide table, this operation is actually not so friendly to the database, we recommend users to use the star model."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"There are many fields in Schema, and there may be more key columns in the aggregation model. The number of columns that need to be sorted in the import process will increase."}),"\n",(0,s.jsx)(n.li,{children:"Dimensional information updates are reflected in the whole table, and the frequency of updates directly affects the efficiency of queries."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the process of using Star Schema, users are advised to use Star Schema to distinguish dimension tables from indicator tables as much as possible. Frequently updated dimension tables can also be placed in MySQL external tables. If there are only a few updates, they can be placed directly in Doris. When storing dimension tables in Doris, more copies of dimension tables can be set up to improve Join's performance."}),"\n",(0,s.jsx)(n.h3,{id:"13-partitioning-and-bucketing",children:"1.3 Partitioning and Bucketing"}),"\n",(0,s.jsx)(n.p,{children:"Doris supports two-level partitioned storage. The first level is partition, which currently supports both RANGE and LIST partition types, and the second layer is HASH bucket."}),"\n",(0,s.jsx)(n.p,{children:"1.3.1. Partitioning"}),"\n",(0,s.jsx)(n.p,{children:"Partition is used to divide data into different intervals, which can be logically understood as dividing the original table into multiple sub-tables. Data can be easily managed by partition, for example, to delete data more quickly."}),"\n",(0,s.jsx)(n.p,{children:"1.3.1.1. Range Partitioning"}),"\n",(0,s.jsx)(n.p,{children:"In business, most users will choose to partition on time, which has the following advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Differentiable heat and cold data"}),"\n",(0,s.jsx)(n.li,{children:"Availability of Doris Hierarchical Storage (SSD + SATA)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"1.3.1.2. List Partitioning"}),"\n",(0,s.jsx)(n.p,{children:"In business,, users can select cities or other enumeration values for partition."}),"\n",(0,s.jsx)(n.p,{children:"1.3.2. Hash Bucketing"}),"\n",(0,s.jsx)(n.p,{children:"The data is divided into different buckets according to the hash value."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It is suggested that columns with large differentiation should be used as buckets to avoid data skew."}),"\n",(0,s.jsx)(n.li,{children:"In order to facilitate data recovery, it is suggested that the size of a single bucket should not be too large and should be kept within 10GB. Therefore, the number of buckets should be considered reasonably when building tables or increasing partitions, among which different partitions can specify different buckets."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"14-sparse-index-and-bloom-filter",children:"1.4 Sparse Index and Bloom Filter"}),"\n",(0,s.jsx)(n.p,{children:"Doris stores the data in an orderly manner, and builds a sparse index for Doris on the basis of ordered data. The index granularity is block (1024 rows)."}),"\n",(0,s.jsx)(n.p,{children:"Sparse index chooses fixed length prefix in schema as index content, and Doris currently chooses 36 bytes prefix as index."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When building tables, it is suggested that the common filter fields in queries should be placed in front of Schema. The more distinguishable the query fields are, the more frequent the query fields are."}),"\n",(0,s.jsxs)(n.li,{children:["One particular feature of this is the varchar type field. The varchar type field can only be used as the last field of the sparse index. The index is truncated at varchar, so if varchar appears in front, the length of the index may be less than 36 bytes. Specifically, you can refer to ",(0,s.jsx)(n.a,{href:"/docs/1.2/data-table/data-model",children:"data model"}),", ",(0,s.jsx)(n.a,{href:"/docs/1.2/data-table/hit-the-rollup",children:"ROLLUP and query"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"In addition to sparse index, Doris also provides bloomfilter index. Bloomfilter index has obvious filtering effect on columns with high discrimination. If you consider that varchar cannot be placed in a sparse index, you can create a bloomfilter index."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"15-rollup",children:"1.5 Rollup"}),"\n",(0,s.jsx)(n.p,{children:"Rollup can essentially be understood as a physical index of the original table. When creating Rollup, only some columns in Base Table can be selected as Schema. The order of fields in Schema can also be different from that in Base Table."}),"\n",(0,s.jsx)(n.p,{children:"Rollup can be considered in the following cases:"}),"\n",(0,s.jsx)(n.p,{children:"1.5.1. Low ratio of data aggregation in the Base Table"}),"\n",(0,s.jsx)(n.p,{children:"This is usually due to the fact that Base Table has more differentiated fields. At this point, you can consider selecting some columns and establishing Rollup."}),"\n",(0,s.jsx)(n.p,{children:"For the `site_visit'table:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"site -u visit (siteid, city, username, pv)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Siteid may lead to a low degree of data aggregation. If business parties often base their PV needs on city statistics, they can build a city-only, PV-based rollup:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ALTER TABLE site_visit ADD ROLLUP rollup_city(city, pv);\n"})}),"\n",(0,s.jsx)(n.p,{children:"1.5.2. The prefix index in Base Table cannot be hit"}),"\n",(0,s.jsx)(n.p,{children:"Generally, the way Base Table is constructed cannot cover all query modes. At this point, you can consider adjusting the column order and establishing Rollup."}),"\n",(0,s.jsx)(n.p,{children:"Database Session"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"session -u data (visitorid, sessionid, visittime, city, province, ip, browser, url)\n"})}),"\n",(0,s.jsx)(n.p,{children:"In addition to visitorid analysis, there are Brower and province analysis cases, Rollup can be established separately."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ALTER TABLE session_data ADD ROLLUP rollup_brower(brower,province,ip,url) DUPLICATE KEY(brower,province);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"schema-change",children:"Schema Change"}),"\n",(0,s.jsx)(n.p,{children:"Users can modify the Schema of an existing table through the Schema Change operation, currently Doris supports the following modifications:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adding and deleting columns"}),"\n",(0,s.jsx)(n.li,{children:"Modify column types"}),"\n",(0,s.jsx)(n.li,{children:"Reorder columns"}),"\n",(0,s.jsx)(n.li,{children:"Adding or modifying Bloom Filter"}),"\n",(0,s.jsx)(n.li,{children:"Adding or removing bitmap index"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For details, please refer to ",(0,s.jsx)(n.a,{href:"/docs/1.2/advanced/alter-table/schema-change",children:"Schema Change"})]})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return o},a:function(){return r}});var t=i(667294);let s={},a=t.createContext(s);function r(e){let n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);