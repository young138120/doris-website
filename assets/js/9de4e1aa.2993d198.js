"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["498731"],{651680:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,contentTitle:()=>l,default:()=>h,assets:()=>o,toc:()=>c,frontMatter:()=>a});var t=JSON.parse('{"id":"admin-manual/data-admin/ccr/overview","title":"Overview","description":"\x3c!--","source":"@site/docs/admin-manual/data-admin/ccr/overview.md","sourceDirName":"admin-manual/data-admin/ccr","slug":"/admin-manual/data-admin/ccr/overview","permalink":"/docs/dev/admin-manual/data-admin/ccr/overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Overview","language":"en-US"},"sidebar":"docs","previous":{"title":"N-Gram BloomFilter Index","permalink":"/docs/dev/table-design/index/ngram-bloomfilter-index"},"next":{"title":"QuickStart","permalink":"/docs/dev/admin-manual/data-admin/ccr/quickstart"}}'),i=r("785893"),s=r("250065");let a={title:"Overview",language:"en-US"},l=void 0,o={},c=[{value:"Overview",id:"overview",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"Job Types",id:"job-types",level:3},{value:"Principles and Architecture",id:"principles-and-architecture",level:2},{value:"Terminology",id:"terminology",level:3},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"Principles",id:"principles",level:3},{value:"Synchronization Modes",id:"synchronization-modes",level:3}];function d(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"CCR (Cross Cluster Replication) is a cross-cluster data synchronization mechanism that synchronizes data changes from the source cluster to the target cluster at the database or table level. It is mainly used to improve data availability for online services, support read-write load isolation, and build a dual-region, three-center architecture."}),"\n",(0,i.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(n.p,{children:"CCR is applicable to the following common scenarios:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Disaster Recovery and Backup"}),": Backing up enterprise data to another cluster and data center ensures that data can be restored or quickly switched to a backup in the event of business interruption or data loss. This high-SLA disaster recovery is commonly required in industries such as finance, healthcare, and e-commerce."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Read/Write Separation"}),": By isolating data query operations from data write operations, the impact between read and write processes is minimized, enhancing service availability. In high-concurrency or high-write-pressure scenarios, read/write separation helps to distribute the load effectively, improving database performance and stability."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Data Centralization"}),": Group headquarters need to centrally manage and analyze data from branch offices located in different regions, avoiding management confusion and decision-making errors caused by inconsistent data, thus improving the efficiency of group management and decision-making quality."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Isolated Upgrades"}),": During system cluster upgrades, CCR can be used to verify and test the new cluster to avoid rollback difficulties due to version compatibility issues. Users can upgrade each cluster incrementally while ensuring data consistency."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cluster Migration"}),": When migrating a Doris cluster to a new data center or replacing hardware, CCR can be used to synchronize data from the old cluster to the new one, ensuring data consistency during the migration process."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"job-types",children:"Job Types"}),"\n",(0,i.jsx)(n.p,{children:"CCR supports two types of jobs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database-Level Jobs"}),": Synchronize data for the entire database."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Table-Level Jobs"}),": Synchronize data for a specific table. Note that table-level synchronization does not support renaming or replacing tables. Additionally, Doris only supports one snapshot job running per database, so table-level full sync jobs must queue for execution."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"principles-and-architecture",children:"Principles and Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"terminology",children:"Terminology"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Source Cluster"}),": The cluster where the data originates, typically where business data is written."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Target Cluster"}),": The cluster where the data is synchronized to in a cross-cluster setup."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Binlog"}),": The change log from the source cluster, containing schema and data changes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Syncer"}),": A lightweight process responsible for synchronizing data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Upstream"}),": In a database-level job, this refers to the source database; in a table-level job, it refers to the source table."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Downstream"}),": In a database-level job, this refers to the target database; in a table-level job, it refers to the target table."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"CCR Architecture Overview",src:r(561852).Z+"",width:"3488",height:"1064"})}),"\n",(0,i.jsxs)(n.p,{children:["CCR relies primarily on a lightweight process called ",(0,i.jsx)(n.code,{children:"Syncer"}),". ",(0,i.jsx)(n.code,{children:"Syncer"})," fetch binlogs from the source cluster, apply the metadata to the target cluster, and instruct the target cluster to pull data from the source cluster, enabling full and incremental synchronization."]}),"\n",(0,i.jsx)(n.h3,{id:"principles",children:"Principles"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Full Synchronization"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The CCR job first performs full synchronization, which copies all data from the upstream to the downstream in one complete operation."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Incremental Synchronization"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"After full synchronization is complete, the CCR job continues with incremental synchronization, keeping the data between the upstream and downstream clusters consistent."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reinitiating Full Synchronization"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If the job encounters a DDL operation that does not support incremental synchronization, the CCR job will restart full synchronization. For a list of DDL operations that do not support incremental synchronization, refer to ",(0,i.jsx)(n.a,{href:"../feature.md",children:"Feature Details"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"If the upstream binlog is interrupted due to expiration or other reasons, the incremental synchronization will stop, triggering a restart of full synchronization."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"During Synchronization"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Incremental synchronization will pause during the full synchronization process."}),"\n",(0,i.jsx)(n.li,{children:"After full synchronization is completed, the downstream tables will undergo atomic replacement to ensure data consistency."}),"\n",(0,i.jsx)(n.li,{children:"After full synchronization is complete, incremental synchronization will resume."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"synchronization-modes",children:"Synchronization Modes"}),"\n",(0,i.jsx)(n.p,{children:"CCR supports four synchronization modes:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Synchronization Mode"}),(0,i.jsx)(n.th,{children:"Principle"}),(0,i.jsx)(n.th,{children:"Trigger Condition"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Full Sync"})}),(0,i.jsx)(n.td,{children:"Full backup of the upstream, restore on the downstream. DB-level jobs trigger DB backup, table-level jobs trigger table backup."}),(0,i.jsxs)(n.td,{children:["Initial synchronization or specific operations trigger this. See ",(0,i.jsx)(n.a,{href:"../feature.md",children:"Feature Details"})," for triggers."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Partial Sync"})}),(0,i.jsx)(n.td,{children:"Backup at the table or partition level from the upstream, restore at the same level on the downstream."}),(0,i.jsxs)(n.td,{children:["Specific operations trigger this. See ",(0,i.jsx)(n.a,{href:"../feature.md",children:"Feature Details"})," for triggers."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"TXN"})}),(0,i.jsx)(n.td,{children:"Incremental data synchronization, downstream starts synchronization after upstream commit."}),(0,i.jsxs)(n.td,{children:["Specific operations trigger this. See ",(0,i.jsx)(n.a,{href:"../feature.md",children:"Feature Details"})," for triggers."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"SQL"})}),(0,i.jsx)(n.td,{children:"Replaying upstream SQL operations on the downstream."}),(0,i.jsxs)(n.td,{children:["Specific operations trigger this. See ",(0,i.jsx)(n.a,{href:"../feature.md",children:"Feature Details"})," for triggers."]})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},561852:function(e,n,r){r.d(n,{Z:function(){return t}});let t=r.p+"assets/images/ccr-architecture-description-555f71e6eddcf0a744f55c0e0b12eb4a.png"},250065:function(e,n,r){r.d(n,{Z:function(){return l},a:function(){return a}});var t=r(667294);let i={},s=t.createContext(i);function a(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);