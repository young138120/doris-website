"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["65911"],{426690:function(e,r,n){n.r(r),n.d(r,{metadata:()=>t,contentTitle:()=>s,default:()=>m,assets:()=>c,toc:()=>l,frontMatter:()=>o});var t=JSON.parse('{"id":"admin-manual/maint-monitor/memory-management/memory-tracker","title":"Memory Tracker","description":"\x3c!--","source":"@site/versioned_docs/version-1.2/admin-manual/maint-monitor/memory-management/memory-tracker.md","sourceDirName":"admin-manual/maint-monitor/memory-management","slug":"/admin-manual/maint-monitor/memory-management/memory-tracker","permalink":"/docs/1.2/admin-manual/maint-monitor/memory-management/memory-tracker","draft":false,"unlisted":false,"tags":[],"version":"1.2","frontMatter":{"title":"Memory Tracker","language":"en"},"sidebar":"docs","previous":{"title":"Metadata Operations and Maintenance","permalink":"/docs/1.2/admin-manual/maint-monitor/metadata-operation"},"next":{"title":"Memory Limit Exceeded Analysis","permalink":"/docs/1.2/admin-manual/maint-monitor/memory-management/memory-limit-exceeded-analysis"}}'),a=n("785893"),i=n("250065");let o={title:"Memory Tracker",language:"en"},s="Memory Tracker",c={},l=[{value:"principle",id:"principle",level:2},{value:"View statistics",id:"view-statistics",level:2},{value:"Home <code>/mem_tracker</code>",id:"home-mem_tracker",level:3},{value:"Global Type <code>/mem_tracker?type=global</code>",id:"global-type-mem_trackertypeglobal",level:3},{value:"Query Type <code>/mem_tracker?type=query</code>",id:"query-type-mem_trackertypequery",level:3},{value:"Load Type <code>/mem_tracker?type=load</code>",id:"load-type-mem_trackertypeload",level:3}];function d(e){let r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",version:"version",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"memory-tracker",children:"Memory Tracker"})}),"\n",(0,a.jsxs)(r.version,{since:"1.2.0",children:["\n",(0,a.jsx)(r.p,{children:"The Memory Tracker records the memory usage of the Doris BE process, including the memory used in the life cycle of tasks such as query, import, Compaction, and Schema Change, as well as various caches for memory control and analysis."}),"\n",(0,a.jsx)(r.h2,{id:"principle",children:"principle"}),"\n",(0,a.jsx)(r.p,{children:"Each query, import and other tasks in the system will create its own Memory Tracker when it is initialized, and put the Memory Tracker into TLS (Thread Local Storage) during execution, and each memory application and release of the BE process will be in the Mem Hook Consume the Memory Tracker in the middle, and display it after the final summary."}),"\n",(0,a.jsxs)(r.p,{children:["For detailed design and implementation, please refer to:\n",(0,a.jsx)(r.a,{href:"https://cwiki.apache.org/confluence/display/DORIS/DSIP-002%3A+Refactor+memory+tracker+on+BE",children:"https://cwiki.apache.org/confluence/display/DORIS/DSIP-002%3A+Refactor+memory+tracker+on+BE"}),"\n",(0,a.jsx)(r.a,{href:"https://shimo.im/docs/DT6JXDRkdTvdyV3G",children:"https://shimo.im/docs/DT6JXDRkdTvdyV3G"})]}),"\n",(0,a.jsx)(r.h2,{id:"view-statistics",children:"View statistics"}),"\n",(0,a.jsxs)(r.p,{children:["The real-time memory statistics results can be viewed through Doris BE's Web page ",(0,a.jsx)(r.code,{children:"http://ip:http_port/mem_tracker"}),".\nFor the memory statistics results of historical queries, you can view the ",(0,a.jsx)(r.code,{children:"peakMemoryBytes"})," of each query in ",(0,a.jsx)(r.code,{children:"fe/log/fe.audit.log"}),", or search ",(0,a.jsx)(r.code,{children:"Deregister query/load memory tracker, queryId"})," in ",(0,a.jsx)(r.code,{children:"be/log/be.INFO"})," `View memory peaks per query on a single BE."]}),"\n",(0,a.jsxs)(r.h3,{id:"home-mem_tracker",children:["Home ",(0,a.jsx)(r.code,{children:"/mem_tracker"})]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{src:"https://user-images.githubusercontent.com/13197424/202889634-fbfdd2a1-e272-4101-8744-baf05c15c2dc.png",alt:"image"})}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"Type: Divide the memory used by Doris BE into the following categories"}),"\n"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"process: The total memory of the process, the sum of all other types."}),"\n",(0,a.jsx)(r.li,{children:"global: Global Memory Tracker with the same life cycle and process, such as each Cache, Tablet Manager, Storage Engine, etc."}),"\n",(0,a.jsx)(r.li,{children:"query: the in-memory sum of all queries."}),"\n",(0,a.jsx)(r.li,{children:"load: Sum of all imported memory."}),"\n",(0,a.jsxs)(r.li,{children:["tc/jemalloc_cache: The general memory allocator TCMalloc or Jemalloc cache, you can view the original profile of the memory allocator in real time at ",(0,a.jsx)(r.code,{children:"http://ip:http_port/memz"}),"."]}),"\n",(0,a.jsx)(r.li,{children:"compaction, schema_change, consistency, batch_load, clone: \u200B\u200Bcorresponding to the memory sum of all Compaction, Schema Change, Consistency, Batch Load, and Clone tasks respectively."}),"\n"]}),"\n",(0,a.jsxs)(r.ol,{start:"2",children:["\n",(0,a.jsx)(r.li,{children:"Current Consumption(Bytes): current memory value, unit B."}),"\n",(0,a.jsx)(r.li,{children:"Current Consumption(Normalize): .G.M.K formatted output of the current memory value."}),"\n",(0,a.jsx)(r.li,{children:"Peak Consumption (Bytes): The peak value of the memory after the BE process is started, the unit is B, and it will be reset after the BE restarts."}),"\n",(0,a.jsx)(r.li,{children:"Peak Consumption(Normalize): The .G.M.K formatted output of the memory peak value after the BE process starts, and resets after the BE restarts."}),"\n"]}),"\n",(0,a.jsxs)(r.h3,{id:"global-type-mem_trackertypeglobal",children:["Global Type ",(0,a.jsx)(r.code,{children:"/mem_tracker?type=global"})]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{src:"https://user-images.githubusercontent.com/13197424/202910945-7ee2bb56-c0a3-4ccb-9422-841c64c65bad.png",alt:"image"})}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"Label: Memory Tracker name"}),"\n",(0,a.jsx)(r.li,{children:"Parent Label: It is used to indicate the parent-child relationship between two Memory Trackers. The memory recorded by the Child Tracker is a subset of the Parent Tracker. There may be intersections between the memories recorded by different Trackers with the same Parent."}),"\n"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"Orphan: Tracker consumed by default. Memory that does not specify a tracker will be recorded in Orphan by default. In addition to the Child Tracker subdivided below, Orphan also includes some memory that is inconvenient to accurately subdivide and count, including BRPC."}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"LoadChannelMgr: The sum of the memory of all imported Load Channel stages, used to write the scanned data to the Segment file on disk, a subset of Orphan."}),"\n",(0,a.jsx)(r.li,{children:"StorageEngine:, the memory consumed by the storage engine during loading the data directory, a subset of Orphan."}),"\n",(0,a.jsx)(r.li,{children:"SegCompaction: The memory sum of all SegCompaction tasks, a subset of Orphan."}),"\n",(0,a.jsx)(r.li,{children:"SegmentMeta: memory use by segment meta data such as footer or index page, a subset of Orphan."}),"\n",(0,a.jsx)(r.li,{children:"TabletManager: The memory consumed by the storage engine get, add, and delte Tablet, a subset of Orphan."}),"\n",(0,a.jsx)(r.li,{children:"BufferAllocator: Only used for memory multiplexing in the non-vectorized Partitioned Agg process, a subset of Orphan."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"DataPageCache: Used to cache data Pages to speed up Scan."}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"IndexPageCache: The index used to cache the data Page, used to speed up Scan."}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"SegmentCache: Used to cache opened Segments, such as index information."}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"DiskIO: Used to cache Disk IO data, only used in non-vectorization."}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"ChunkAllocator: Used to cache power-of-2 memory blocks, and reuse memory at the application layer."}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"LastestSuccessChannelCache: Used to cache the LoadChannel of the import receiver."}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"DeleteBitmap AggCache: Gets aggregated delete_bitmap on rowset_id and version."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.h3,{id:"query-type-mem_trackertypequery",children:["Query Type ",(0,a.jsx)(r.code,{children:"/mem_tracker?type=query"})]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{src:"https://user-images.githubusercontent.com/13197424/202924569-c4f3c556-2f92-4375-962c-c71147704a27.png",alt:"image"})}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["Limit: The upper limit of memory used by a single query, ",(0,a.jsx)(r.code,{children:"show session variables"})," to view and modify ",(0,a.jsx)(r.code,{children:"exec_mem_limit"}),"."]}),"\n",(0,a.jsxs)(r.li,{children:["Label: The label naming rule of the Tracker for a single query is ",(0,a.jsx)(r.code,{children:"Query#Id=xxx"}),"."]}),"\n",(0,a.jsxs)(r.li,{children:["Parent Label: Parent is the Tracker record of ",(0,a.jsx)(r.code,{children:"Query#Id=xxx"})," to query the memory used by different operators during execution."]}),"\n"]}),"\n",(0,a.jsxs)(r.h3,{id:"load-type-mem_trackertypeload",children:["Load Type ",(0,a.jsx)(r.code,{children:"/mem_tracker?type=load"})]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{src:"https://user-images.githubusercontent.com/13197424/202925855-936889e3-c910-4ca5-bc12-1b9849a09c33.png",alt:"image"})}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["Limit: The import is divided into two stages: Fragment Scan and Load Channel to write Segment to disk. The upper memory limit of the Scan phase can be viewed and modified through ",(0,a.jsx)(r.code,{children:"show session variables"}),"; the segment write disk phase does not have a separate memory upper limit for each import, but the total upper limit of all imports, corresponding to ",(0,a.jsx)(r.code,{children:"load_process_max_memory_limit_percent"}),"."]}),"\n",(0,a.jsxs)(r.li,{children:["Label: The label naming rule of a single import Scan stage Tracker is ",(0,a.jsx)(r.code,{children:"Load#Id=xxx"}),"; the Label naming rule of a single import Segment write disk stage Tracker is ",(0,a.jsx)(r.code,{children:"LoadChannel#senderIp=xxx#loadID=xxx"}),"."]}),"\n",(0,a.jsxs)(r.li,{children:["Parent Label: Parent is the Tracker of ",(0,a.jsx)(r.code,{children:"Load#Id=xxx"}),", which records the memory used by different operators during the import Scan stage; Parent is the Tracker of ",(0,a.jsx)(r.code,{children:"LoadChannelMgrTrackerSet"}),", which records the Insert and The memory used by the Flush disk process is associated with the last ",(0,a.jsx)(r.code,{children:"loadID"})," of the Label to write to the disk stage Tracker of the Segment."]}),"\n"]}),"\n"]})]})}function m(e={}){let{wrapper:r}={...(0,i.a)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},250065:function(e,r,n){n.d(r,{Z:function(){return s},a:function(){return o}});var t=n(667294);let a={},i=t.createContext(a);function o(e){let r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);