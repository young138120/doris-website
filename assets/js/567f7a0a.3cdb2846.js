"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["790038"],{431363:function(e,r,s){s.r(r),s.d(r,{metadata:()=>n,contentTitle:()=>a,default:()=>c,assets:()=>l,toc:()=>u,frontMatter:()=>o});var n=JSON.parse('{"id":"admin-manual/resource-admin/workload-analysis","title":"Workload Analysis","description":"\x3c!--","source":"@site/versioned_docs/version-3.0/admin-manual/resource-admin/workload-analysis.md","sourceDirName":"admin-manual/resource-admin","slug":"/admin-manual/resource-admin/workload-analysis","permalink":"/docs/3.0/admin-manual/resource-admin/workload-analysis","draft":false,"unlisted":false,"tags":[],"version":"3.0","frontMatter":{"title":"Workload Analysis","language":"en"},"sidebar":"docs","previous":{"title":"Workload Policy","permalink":"/docs/3.0/admin-manual/resource-admin/workload-policy"},"next":{"title":"Resource Group","permalink":"/docs/3.0/admin-manual/resource-admin/multi-tenant"}}'),t=s("785893"),i=s("250065");let o={title:"Workload Analysis",language:"en"},a=void 0,l={},u=[{value:"Workload Table",id:"workload-table",level:2},{value:"active_queries",id:"active_queries",level:3},{value:"backend_active_tasks",id:"backend_active_tasks",level:3},{value:"workload_group_resource_usage",id:"workload_group_resource_usage",level:3},{value:"Workload Analysis and Handling Methods",id:"workload-analysis-and-handling-methods",level:2},{value:"Commonly Used SQL",id:"commonly-used-sql",level:2}];function d(e){let r={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"Doris supports analyzing workloads in the cluster through the Workload system tables, addressing the following issues:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"It helps users understand the resource utilization of each Workload Group, allowing for reasonable setting of resource limits to avoid waste."}),"\n",(0,t.jsx)(r.li,{children:"When cluster availability decreases due to insufficient resources, the system tables can be used to quickly identify the current resource usage distribution, enabling the formulation of appropriate resource management decisions to restore cluster availability."}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"workload-table",children:"Workload Table"}),"\n",(0,t.jsxs)(r.p,{children:["All tables are in the database",(0,t.jsx)(r.code,{children:"information_schema"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"active_queries",children:"active_queries"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"active_queries"})," records quereis in FE:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"query_id, query's id"}),"\n",(0,t.jsx)(r.li,{children:"query_start_time, the time when the query starts executing; if the query was queued, it represents the time when execution begins after the queuing ends."}),"\n",(0,t.jsx)(r.li,{children:"query_time_ms, the duration of the query, measured in milliseconds."}),"\n",(0,t.jsx)(r.li,{children:"workload_group_id, the ID of the workload group used by the query."}),"\n",(0,t.jsx)(r.li,{children:"database, the database used by the SQL query."}),"\n",(0,t.jsx)(r.li,{children:"frontend_instance, the node name of the FE where the query is located."}),"\n",(0,t.jsx)(r.li,{children:"queue_start_time, if the query enters the queuing logic upon arrival, it represents the time point when the query started queuing."}),"\n",(0,t.jsx)(r.li,{children:"queue_end_time, if the query enters the queuing logic upon arrival, it represents the time point when the query finishes queuing."}),"\n",(0,t.jsx)(r.li,{children:"query_status, the current status of the query, which mainly has two values: RUNNING and QUEUED. RUNNING indicates that the query is currently running, while QUEUED means that the query is currently in the queue."}),"\n",(0,t.jsx)(r.li,{children:"sql, sql content."}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"backend_active_tasks",children:"backend_active_tasks"}),"\n",(0,t.jsx)(r.p,{children:"A query is typically divided into multiple fragments and executed on multiple BEs. The backend_active_tasks represents the total amount of CPU and memory resources used by a query on a single BE. If the query has multiple concurrent fragments on a single BE, the data will be aggregated into a single row.\nDetailed information about the fields is as follows:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"be_id, backend id."}),"\n",(0,t.jsx)(r.li,{children:"fe_host, Represents which FE the query was submitted from."}),"\n",(0,t.jsx)(r.li,{children:"query_id, query's id."}),"\n",(0,t.jsx)(r.li,{children:"task_time_ms, query running time in BE, measured in milliseconds."}),"\n",(0,t.jsx)(r.li,{children:"task_cpu_time_ms, CPU time of the query while executing on the BE, measured in milliseconds."}),"\n",(0,t.jsx)(r.li,{children:"scan_rows, the number of rows scanned by the query on the current BE. If multiple tables are scanned, this value is the sum of rows scanned across all those tables."}),"\n",(0,t.jsx)(r.li,{children:"scan_bytes, the number of bytes scanned by the query on the current BE. If multiple tables are scanned, this value is the sum of bytes scanned across all those tables."}),"\n",(0,t.jsx)(r.li,{children:"be_peak_memory_bytes, the peak memory usage of the query on the current BE, measured in bytes."}),"\n",(0,t.jsx)(r.li,{children:"current_used_memory_bytes, the amount of memory currently used by the query on the current BE, measured in bytes."}),"\n",(0,t.jsx)(r.li,{children:"shuffle_send_bytes, the number of bytes sent by the query as a shuffle client on the current node."}),"\n",(0,t.jsx)(r.li,{children:"shuffle_send_rows, the number of rows sent by the query as a shuffle client on the current node."}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"workload_group_resource_usage",children:"workload_group_resource_usage"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"workload_group_resource_usage"}),"table provides real-time information on the current resource usage of Workload Groups.\nThe field descriptions are as follows:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"be_id, backend's i."}),"\n",(0,t.jsx)(r.li,{children:"workload_group_id, workload group's id."}),"\n",(0,t.jsx)(r.li,{children:"memory_usage_bytes, workload group's memory usage."}),"\n",(0,t.jsx)(r.li,{children:"cpu_usage_percent, the percentage of CPU usage by the Workload Group, calculated as the total CPU active time of the Workload Group in 1 second divided by the total available CPU time in 1 second. This value is the average over the last 10 seconds."}),"\n",(0,t.jsx)(r.li,{children:"local_scan_bytes_per_second, the number of bytes read per second by the Workload Group from local files. Note that due to Doris's Page Cache and operating system cache, this value is typically higher than what is monitored using system tools like pidstat. If multiple directories are configured, this value is the sum of I/O reads from all directories. For per-directory read I/O throughput, detailed data can be found in BE's bvar monitoring."}),"\n",(0,t.jsx)(r.li,{children:"remote_scan_bytes_per_second, the number of bytes read per second by the Workload Group from remote data."}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"workload-analysis-and-handling-methods",children:"Workload Analysis and Handling Methods"}),"\n",(0,t.jsx)(r.p,{children:"When monitoring indicates a decrease in cluster availability, you can follow these steps to address the issue:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Identify the Bottleneck: First, use monitoring to roughly determine the current bottleneck in the cluster, such as high memory usage, high CPU usage, or high I/O. If all are high, prioritize resolving memory issues."}),"\n",(0,t.jsx)(r.li,{children:"Examine Resource Usage: After identifying the cluster bottleneck, use the workload_group_resource_usage table to identify the Workload Groups with the highest resource usage. For example, if memory is the bottleneck, find the top N groups with the highest memory usage."}),"\n",(0,t.jsx)(r.li,{children:"Reduce Query Concurrency: Once you have identified the groups with the highest resource usage, try reducing the query concurrency for these groups. Since cluster resources are already tight, avoid allowing new queries to exhaust the cluster's resources."}),"\n",(0,t.jsx)(r.li,{children:"Degrade Queries: Apply degradation to the queries in the current group based on the type of bottleneck:"}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"For CPU Bottleneck: Set the group's CPU to a hard limit and adjust cpu_hard_limit to a lower value to proactively release CPU resources."}),"\n",(0,t.jsx)(r.li,{children:"For I/O Bottleneck: Limit the group's maximum I/O using the read_bytes_per_second parameter."}),"\n",(0,t.jsx)(r.li,{children:"For Memory Bottleneck: Set the group's memory to a hard limit and reduce the memory_limit value to free up some memory. Be aware that this may cause many queries in the group to fail."}),"\n"]}),"\n",(0,t.jsxs)(r.ol,{start:"5",children:["\n",(0,t.jsx)(r.li,{children:"Further Analysis: After completing the above steps, the cluster\u2019s availability should improve. Conduct further analysis to determine whether the increase in resource usage is due to higher overall query concurrency in the group or specific large queries. If specific large queries are causing the issue, quickly killing these large queries can help recover the system."}),"\n",(0,t.jsx)(r.li,{children:"Kill Abnormal Queries: Use backend_active_tasks in conjunction with active_queries to identify SQL queries with abnormal resource usage in the cluster. Then, use the KILL statement to terminate these queries and free up resources."}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"commonly-used-sql",children:"Commonly Used SQL"}),"\n",(0,t.jsxs)(r.admonition,{type:"tip",children:[(0,t.jsx)(r.p,{children:"Note that the active_queries table records queries running on the FE, while the backend_active_tasks table records queries running on the BE. Not all queries are registered with the FE during execution; for example, stream loads are not registered with the FE. Therefore, it is normal to get no matching results when performing a LEFT JOIN between backend_active_tasks and active_queries."}),(0,t.jsx)(r.p,{children:"When a query is a SELECT query, the queryId recorded in both active_queries and backend_active_tasks is the same. When a query is a stream load, the queryId in the active_queries table is empty, while the queryId in backend_active_tasks is the ID of the stream load."})]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"View all current Workload Groups and display them in descending order of memory/CPU/I/O usage."}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"select be_id,workload_group_id,memory_usage_bytes,cpu_usage_percent,local_scan_bytes_per_second \n   from workload_group_resource_usage\norder by  memory_usage_bytes,cpu_usage_percent,local_scan_bytes_per_second desc\n"})}),"\n",(0,t.jsxs)(r.ol,{start:"2",children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Cpu usage TopN Sql."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"select \n        t1.query_id as be_query_id,\n        t1.query_type,\n        t2.query_id,\n        t2.workload_group_id,\n        t2.`database`,\n        t1.cpu_time,\n        t2.`sql`\nfrom\n(select query_id, query_type,sum(task_cpu_time_ms) as cpu_time from backend_active_tasks group by query_id, query_type) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id\norder by cpu_time desc limit 10;\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Memory usage TopN Sql."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"select \n        t1.query_id as be_query_id,\n        t1.query_type,\n        t2.query_id,\n        t2.workload_group_id,\n        t1.mem_used\nfrom\n(select query_id, query_type, sum(current_used_memory_bytes) as mem_used from backend_active_tasks group by query_id, query_type) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \norder by mem_used desc limit 10;\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Scan bytes/rows TopN Sql."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"select \n        t1.query_id as be_query_id,\n        t1.query_type,\n        t2.query_id,\n        t2.workload_group_id,\n        t1.scan_rows,\n        t1.scan_bytes\nfrom\n(select query_id, query_type, sum(scan_rows) as scan_rows,sum(scan_bytes) as scan_bytes from backend_active_tasks group by query_id,query_type) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \norder by scan_rows desc,scan_bytes desc limit 10;\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Show workload group's scan rows/bytes."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"select \n        t2.workload_group_id,\n        sum(t1.scan_rows) as wg_scan_rows,\n        sum(t1.scan_bytes) as wg_scan_bytes\nfrom\n(select query_id, sum(scan_rows) as scan_rows,sum(scan_bytes) as scan_bytes from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \ngroup by t2.workload_group_id\norder by wg_scan_rows desc,wg_scan_bytes desc\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Show workload group's query queue details."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"select \n         workload_group_id,\n         query_id,\n         query_status,\n         now() - queue_start_time as queued_time\nfrom \n     active_queries\nwhere query_status='queued'\norder by workload_group_id\n"})}),"\n"]}),"\n"]})]})}function c(e={}){let{wrapper:r}={...(0,i.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},250065:function(e,r,s){s.d(r,{Z:function(){return a},a:function(){return o}});var n=s(667294);let t={},i=n.createContext(t);function o(e){let r=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);