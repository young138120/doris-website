"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["356374"],{494747:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,contentTitle:()=>i,default:()=>h,assets:()=>l,toc:()=>c,frontMatter:()=>s});var t=JSON.parse('{"id":"table-design/row-store","title":"Hybrid Storage","description":"\x3c!--","source":"@site/docs/table-design/row-store.md","sourceDirName":"table-design","slug":"/table-design/row-store","permalink":"/docs/dev/table-design/row-store","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Hybrid Storage","language":"en"},"sidebar":"docs","previous":{"title":"Reference","permalink":"/docs/dev/admin-manual/data-admin/ccr/manual"},"next":{"title":"Basic concepts","permalink":"/docs/dev/table-design/data-partitioning/basic-concepts"}}'),o=r("785893"),a=r("250065");let s={title:"Hybrid Storage",language:"en"},i=void 0,l={},c=[{value:"Hybrid Storage",id:"hybrid-storage",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Example",id:"example",level:2},{value:"Notice",id:"notice",level:2}];function d(e){let n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"hybrid-storage",children:"Hybrid Storage"}),"\n",(0,o.jsxs)(n.p,{children:["Doris defaults to columnar storage, where each column is stored contiguously. Columnar storage offers excellent performance for analytical scenarios (such as aggregation, filtering, sorting, etc.), as it only reads the necessary columns, reducing unnecessary IO. However, in point query scenarios (such as ",(0,o.jsx)(n.code,{children:"SELECT *"}),"), all columns need to be read, requiring an IO operation for each column, which can lead to IOPS becoming a bottleneck, especially for wide tables with many columns (e.g., hundreds of columns)."]}),"\n",(0,o.jsxs)(n.p,{children:["To address the IOPS bottleneck in point query scenarios, starting from version 2.0.0, Doris supports hybrid storage. When users create tables, they can specify whether to enable row storage. With row storage enabled, each row only requires one IO operation for point queries (such as ",(0,o.jsx)(n.code,{children:"SELECT *"}),"), significantly improving performance."]}),"\n",(0,o.jsx)(n.p,{children:"The principle of row storage is that an additional column is added during storage. This column concatenates all the columns of the corresponding row and stores them using a special binary format."}),"\n",(0,o.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,o.jsx)(n.p,{children:"When creating a table, specify whether to enable row storage, which columns to enable row storage for, and the storage compression unit size page_size in the table's PROPERTIES."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Whether to enable row storage: defaults to false (not enabled)."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'"store_row_column" = "true"\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsxs)(n.li,{children:["Which columns to enable row storage for:if ",(0,o.jsx)(n.code,{children:'"store_row_column" = "true"'}),", all columns are enabled by default. If you need to specify that only some columns are enabled for row storage, set the row_store_columns parameter, formatted as a comma-separated list of column names."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'"row_store_columns" = "column1,column2,column3"\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:"Row storage page_size: defaults to 16KB."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'"row_store_page_size" = "16384"\n'})}),"\n",(0,o.jsx)(n.p,{children:"The page is the smallest unit of storage read/write operations, and page_size is the size of the row storage page. This means that reading one row also requires generating an IO for a page. The larger the value, the better the compression effect and the lower the storage space usage, but the higher the IO overhead for point queries (since one IO reads at least one page), and vice versa. The smaller the value, the higher the storage space, the better the point query performance. The default value of 16KB is a balanced choice in most cases. If you prefer query performance, you can configure a smaller value such as 4KB or even lower. If you prefer storage space, you can configure a larger value such as 64KB or even higher."}),"\n",(0,o.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.p,{children:'The example below creates an 8-column table, where "key,v1,v3,v5,v7" are the 5 columns enabled for row storage. To optimize for high-concurrency point query performance, the page_size is configured to 4KB.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'CREATE TABLE `tbl_point_query` (\n     `key` int(11) NULL,\n     `v1` decimal(27, 9) NULL,\n     `v2` varchar(30) NULL,\n     `v3` varchar(30) NULL,\n     `v4` date NULL,\n     `v5` datetime NULL,\n     `v6` float NULL,\n     `v7` datev2 NULL\n) ENGINE=OLAP\nUNIQUE KEY(`key`)\nCOMMENT \'OLAP\'\nDISTRIBUTED BY HASH(`key`) BUCKETS 1\nPROPERTIES (\n     "enable_unique_key_merge_on_write" = "true",\n     "light_schema_change" = "true",\n     "row_store_columns" = "key,v1,v3,v5,v7",\n     "row_store_page_size" = "4096"\n);\n'})}),"\n",(0,o.jsx)(n.p,{children:"Query"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"SELECT key, v1, v3, v5, v7 FROM tbl_point_query WHERE key = 100\uFF1B\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For more information on point query usage, please refer to ",(0,o.jsx)(n.a,{href:"../query-acceleration/high-concurrent-point-query",children:"High-Concurrent Point Query"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"notice",children:"Notice"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Enabling row storage will increase the storage space used. The increase in storage space is related to the data characteristics and is generally 2 to 10 times the size of the original table. The exact space usage needs to be tested with actual data."}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"page_size"})," of row storage also affects the storage space. You can adjust it based on the previous table attribute parameter ",(0,o.jsx)(n.code,{children:"row_store_page_size"}),"."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return i},a:function(){return s}});var t=r(667294);let o={},a=t.createContext(o);function s(e){let n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);