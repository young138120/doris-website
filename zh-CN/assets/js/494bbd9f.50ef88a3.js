"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["380623"],{566114:function(e,n,s){s.r(n),s.d(n,{metadata:()=>t,contentTitle:()=>a,default:()=>c,assets:()=>u,toc:()=>d,frontMatter:()=>o});var t=JSON.parse('{"id":"admin-manual/resource-admin/workload-system-table","title":"Workload System Table","description":"\x3c!--","source":"@site/versioned_docs/version-2.1/admin-manual/resource-admin/workload-system-table.md","sourceDirName":"admin-manual/resource-admin","slug":"/admin-manual/resource-admin/workload-system-table","permalink":"/zh-CN/docs/admin-manual/resource-admin/workload-system-table","draft":false,"unlisted":false,"tags":[],"version":"2.1","frontMatter":{"title":"Workload System Table","language":"en"}}'),i=s("785893"),r=s("250065");let o={title:"Workload System Table",language:"en"},a=void 0,u={},d=[{value:"Backgroup",id:"backgroup",level:2},{value:"Workload System Table Introduction",id:"workload-system-table-introduction",level:2},{value:"active_queries",id:"active_queries",level:3},{value:"backend_active_tasks",id:"backend_active_tasks",level:3},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Application scenarios",id:"application-scenarios",level:2},{value:"Find SQL with the highest CPU usage",id:"find-sql-with-the-highest-cpu-usage",level:3},{value:"Find SQL with the highest memory usage",id:"find-sql-with-the-highest-memory-usage",level:3},{value:"Find queries which scan too much data",id:"find-queries-which-scan-too-much-data",level:3}];function l(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"backgroup",children:"Backgroup"}),"\n",(0,i.jsx)(n.p,{children:"Doris supports analyzing the resource usage of running workloads through the Workload system table, commonly used in the following scenarios:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"View the resource usage of Workload Group in the cluster, including CPU and memory."}),"\n",(0,i.jsx)(n.li,{children:"View the TopN SQL with the highest resource usage in the current cluster."}),"\n",(0,i.jsx)(n.li,{children:"View the queue status of Workload Groups in the cluster"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Users can query this information by submitting SQL, identify the Workload Group or SQL with high resource usage in the system, and perform corresponding processing."}),"\n",(0,i.jsx)(n.h2,{id:"workload-system-table-introduction",children:"Workload System Table Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["At present, the system tables are in database ",(0,i.jsx)(n.code,{children:"information_schema"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"active_queries",children:"active_queries"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"active_queries"})," table records the execution information of the current query on FE, and the detailed information of the fields is as follows\uFF1A"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"query_id, query's id"}),"\n",(0,i.jsx)(n.li,{children:"query_start_time, the start time of the query execution; If query queues, it represents the time when execution starts after the queue ends"}),"\n",(0,i.jsx)(n.li,{children:"query_time_ms, the query time, in milliseconds"}),"\n",(0,i.jsx)(n.li,{children:"workload_group_id, workload group's id"}),"\n",(0,i.jsx)(n.li,{children:"database, sql's database"}),"\n",(0,i.jsx)(n.li,{children:"frontend_instance, the FE which query is submitted"}),"\n",(0,i.jsx)(n.li,{children:"queue_start_time, if query queues, it means the time that query begins to queue"}),"\n",(0,i.jsx)(n.li,{children:"queue_end_time, if query queues, it means the time that query ends to queue"}),"\n",(0,i.jsx)(n.li,{children:"query_status, query status, it has two value RUNNING and QUEUED, RUNNIG means query is running; QUEUED means query is queued."}),"\n",(0,i.jsx)(n.li,{children:"sql, sql content"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"backend_active_tasks",children:"backend_active_tasks"}),"\n",(0,i.jsxs)(n.p,{children:["A query is usually divided into multiple fragments to be executed on multiple BEs, and ",(0,i.jsx)(n.code,{children:"backend_active_tasks"})," table represent the total amount of CPU and memory resources used by a query on a single BE. If this query has multiple concurrency and fragments on a single BE, it will also be summarized into one row of data.\nThe detailed information of the fields is as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"be_id, BE's id"}),"\n",(0,i.jsx)(n.li,{children:"fe_host, it represents which FE this query was submitted from"}),"\n",(0,i.jsx)(n.li,{children:"query_id, query's id"}),"\n",(0,i.jsx)(n.li,{children:"task_time_ms, query execution time on the current BE, in milliseconds"}),"\n",(0,i.jsx)(n.li,{children:"task_cpu_time_ms\uFF0Cquery cpu time on the current BE, in milliseconds"}),"\n",(0,i.jsx)(n.li,{children:"scan_rows, the number of rows scanned on the current BE. If multiple tables are scanned, it is the cumulative value of multiple tables"}),"\n",(0,i.jsx)(n.li,{children:"scan_bytes, the number of bytes scanned on the current BE. If multiple tables are scanned, it is the cumulative value of multiple tables"}),"\n",(0,i.jsx)(n.li,{children:"be_peak_memory_bytes, the peak memory usage on the current BE, in bytes"}),"\n",(0,i.jsx)(n.li,{children:"current_used_memory_bytes, the amount of memory currently in use on the BE, in bytes"}),"\n",(0,i.jsx)(n.li,{children:"shuffle_send_bytes, the number of bytes sent as shuffle clients at the BE"}),"\n",(0,i.jsx)(n.li,{children:"shuffle_send_rows, the number of rows sent as shuffle clients at the BE"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"TopN resource usage sql"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.query_id,\n        t2.workload_group_id,\n        t2.`database`,\n        t1.cpu_time,\n        t1.mem_used,\n        t2.`sql`\nfrom\n(select query_id, sum(task_cpu_time_ms) as cpu_time,sum(current_used_memory_bytes) as mem_used from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \norder by cpu_time desc, mem_used desc limit 10;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"TopN resource usage sql on BE"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.query_id,\n        t2.workload_group_id,\n        t2.`database`,\n        t1.cpu_time,\n        t1.mem_used,\n        t2.`sql`\nfrom\n(select query_id, sum(task_cpu_time_ms) as cpu_time,sum(current_used_memory_bytes) as mem_used \n    from backend_active_tasks where be_id=12345 group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \norder by cpu_time desc, mem_used desc limit 10;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"WorkloadGroup queue details"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n    workload_group_id, \n    sum(case when query_status='QUEUED' then 1 else 0 end) as queue_num, \n    sum(case when query_status='RUNNING' then 1 else 0 end) as running_query_num\nfrom \n    active_queries\ngroup by workload_group_id\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Query queue time"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n         workload_group_id,\n         query_id,\n         query_status,\n         now() - queue_start_time as queued_time\nfrom \n     active_queries\nwhere query_status='queued'\norder by workload_group_id\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"application-scenarios",children:"Application scenarios"}),"\n",(0,i.jsx)(n.p,{children:"When the query latency of the cluster increases and the availability decreases, bottleneck points can be identified through the overall monitoring of the cluster:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"When the CPU resources of BE are fully utilized and the memory usage is not high, it indicates that the main bottleneck should be on the CPU."}),"\n",(0,i.jsx)(n.li,{children:"When the CPU and memory resources of BE are both high, it indicates that the main bottleneck is in memory."}),"\n",(0,i.jsx)(n.li,{children:"When the CPU and memory resource usage of BE is not high, but the IO usage is high, it indicates that the main bottleneck is in IO."}),"\n",(0,i.jsx)(n.li,{children:"The CPU/memory/IO is not high, but there are many queued queries, indicating that the queue parameter configuration is unreasonable. You can try increasing the queue concurrency."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"After identifying the bottleneck points of the cluster, the SQL that is currently using more resources can be further analyzed through the workload system table, and then the query can be downgraded."}),"\n",(0,i.jsx)(n.h3,{id:"find-sql-with-the-highest-cpu-usage",children:"Find SQL with the highest CPU usage"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"TopN CPU usage sql"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.query_id,\n        t2.workload_group_id,\n        t2.`database`,\n        t1.cpu_time,\n        t2.`sql`\nfrom\n(select query_id, sum(task_cpu_time_ms) as cpu_time from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id\norder by cpu_time desc limit 10;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Workload group cpu time"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.workload_group_id,\n        sum(t1.cpu_time) cpu_time\nfrom\n(select query_id, sum(task_cpu_time_ms) as cpu_time from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \ngroup by workload_group_id order by cpu_time desc\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the CPU usage of a single SQL is too high, it can be alleviated by canceling the query."}),"\n",(0,i.jsx)(n.p,{children:"If SQL with longer CPU time comes from the same workload group, CPU usage can be reduced by lowering the CPU priority of this workload group or lowering the number of scan threads."}),"\n",(0,i.jsx)(n.h3,{id:"find-sql-with-the-highest-memory-usage",children:"Find SQL with the highest memory usage"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"TopN memory usage sql"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.query_id,\n        t2.workload_group_id,\n        t1.mem_used\nfrom\n(select query_id, sum(current_used_memory_bytes) as mem_used from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \norder by mem_used desc limit 10;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Workload group memory usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.workload_group_id,\n        sum(t1.mem_used) wg_mem_used\nfrom\n(select query_id, sum(current_used_memory_bytes) as mem_used from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \ngroup by t2.workload_group_id order by wg_mem_used desc\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If a single query occupies most of the memory, then killing this query can be used to quickly free up memory."}),"\n",(0,i.jsx)(n.p,{children:"If a lower priority workload group is using more memory, memory can be released by downgrading this workload group:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If the memory configuration is soft limit, it can be modified to hard limit and the memory limit of the workload group can be reduced"}),"\n",(0,i.jsx)(n.li,{children:"Reduce the query concurrency of the workload group through its queuing function"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"find-queries-which-scan-too-much-data",children:"Find queries which scan too much data"}),"\n",(0,i.jsx)(n.p,{children:"At present, Doris does not directly collect indicators of disk IO for queries, but it can indirectly find SQL with heavier scans through the number of scan rows and scan bytes."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"TopN scan data query"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.query_id,\n        t2.workload_group_id,\n        t1.scan_rows,\n        t1.scan_bytes\nfrom\n(select query_id, sum(scan_rows) as scan_rows,sum(scan_bytes) as scan_bytes from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \norder by scan_rows desc,scan_bytes desc limit 10;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Workload group scan data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select \n        t2.workload_group_id,\n        sum(t1.scan_rows) as wg_scan_rows,\n        sum(t1.scan_bytes) as wg_scan_bytes\nfrom\n(select query_id, sum(scan_rows) as scan_rows,sum(scan_bytes) as scan_bytes from backend_active_tasks group by query_id) \n        t1 left join active_queries t2\non t1.query_id = t2.query_id \ngroup by t2.workload_group_id\norder by wg_scan_rows desc,wg_scan_bytes desc\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the scan data volume of a single SQL statement is large, then a kill query can be used to check if there will be any relief."}),"\n",(0,i.jsx)(n.p,{children:"If the scanning data volume of a certain workload group is large, IO can be reduced by lowering the number of scanning threads of the workload group."})]})}function c(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return a},a:function(){return o}});var t=s(667294);let i={},r=t.createContext(i);function o(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);